<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5, user-scalable=yes">
    <link rel="manifest" href="/games/ms_manifest.json">
    <meta name="theme-color" content="#001428">
    <title>CyberSweeper 2025 - Blockchain Arcade Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        :root {
            --cell-size: clamp(25px, 5vw, 40px);
            --gap-size: clamp(2px, 0.3vw, 3px);
            --border-radius: clamp(3px, 0.5vw, 5px);
            --font-scale: clamp(0.8rem, 1.5vw, 1rem);
            --title-scale: clamp(2rem, 6vw, 3.5rem);
            --padding-scale: clamp(10px, 2vw, 20px);
            --modal-width: min(90vw, 500px);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: #0ff;
            overflow-x: hidden;
            position: relative;
            min-height: 100vh;
            min-height: -webkit-fill-available;
        }
        
        #three-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .game-container {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: var(--padding-scale);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: radial-gradient(ellipse at center, rgba(0,255,255,0.05) 0%, transparent 70%);
        }
        
        .cyber-title {
            font-size: var(--title-scale);
            font-weight: 900;
            text-transform: uppercase;
            background: linear-gradient(45deg, #0ff, #0f0, #f0f);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 clamp(20px, 3vw, 30px) rgba(0,255,255,0.8);
            animation: glitch 2s infinite, titleFloat 4s ease-in-out infinite;
            margin-bottom: clamp(15px, 2vw, 20px);
            text-align: center;
            line-height: 1.2;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
        
        @keyframes titleFloat {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-5px) scale(1.02); }
        }
        
        .stats-panel {
            display: flex;
            flex-wrap: wrap;
            gap: clamp(15px, 2vw, 30px);
            margin-bottom: clamp(15px, 2vw, 20px);
            padding: clamp(10px, 1.5vw, 15px) clamp(15px, 2vw, 30px);
            background: rgba(0,20,40,0.8);
            border: 2px solid #0ff;
            border-radius: clamp(10px, 1.5vw, 15px);
            box-shadow: 0 0 clamp(20px, 3vw, 30px) rgba(0,255,255,0.5), 
                        inset 0 0 clamp(15px, 2vw, 20px) rgba(0,255,255,0.1);
            animation: statsGlow 3s ease-in-out infinite;
            width: min(95vw, 600px);
            justify-content: center;
        }
        
        @keyframes statsGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0,255,255,0.5), inset 0 0 20px rgba(0,255,255,0.1); }
            50% { box-shadow: 0 0 40px rgba(0,255,255,0.8), inset 0 0 30px rgba(0,255,255,0.2); }
        }
        
        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: statPulse 2s ease-in-out infinite;
            animation-delay: calc(var(--stat-index, 0) * 0.2s);
        }
        
        @keyframes statPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .stat-label {
            font-size: clamp(0.7rem, 1.2vw, 0.8rem);
            color: #0f0;
            text-transform: uppercase;
            margin-bottom: clamp(3px, 0.5vw, 5px);
            text-shadow: 0 0 5px currentColor;
        }
        
        .stat-value {
            font-size: clamp(1.3rem, 2.5vw, 1.8rem);
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px currentColor;
            animation: valueShine 2s linear infinite;
        }
        
        @keyframes valueShine {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        #game-board {
            position: relative;
            padding: clamp(15px, 2vw, 20px);
            background: linear-gradient(135deg, rgba(0,50,100,0.9), rgba(0,20,40,0.9));
            border: 3px solid #0ff;
            border-radius: clamp(15px, 2vw, 20px);
            box-shadow: 
                0 0 clamp(30px, 5vw, 50px) rgba(0,255,255,0.7),
                inset 0 0 clamp(20px, 3vw, 30px) rgba(0,255,255,0.2),
                0 clamp(5px, 1vw, 10px) clamp(20px, 3vw, 30px) rgba(0,0,0,0.8);
            animation: boardPulse 3s ease-in-out infinite, boardRotate 20s linear infinite;
            transform-style: preserve-3d;
        }
        
        @keyframes boardPulse {
            0%, 100% { transform: scale(1) perspective(1000px) rotateX(0deg); }
            50% { transform: scale(1.02) perspective(1000px) rotateX(2deg); }
        }
        
        @keyframes boardRotate {
            0% { filter: hue-rotate(0deg); }
            100% { filter: hue-rotate(10deg); }
        }
        
        .game-grid {
            display: grid;
            gap: var(--gap-size);
            padding: clamp(8px, 1vw, 10px);
            background: rgba(0,0,0,0.5);
            border-radius: clamp(8px, 1vw, 10px);
            position: relative;
        }
        
        .game-grid::before {
            content: '';
            position: absolute;
            inset: -2px;
            background: linear-gradient(45deg, #0ff, #0f0, #f0f, #0ff);
            border-radius: clamp(8px, 1vw, 10px);
            opacity: 0;
            animation: gridBorderGlow 3s ease-in-out infinite;
            z-index: -1;
            filter: blur(5px);
        }
        
        @keyframes gridBorderGlow {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.5; }
        }
        
        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background: linear-gradient(135deg, #001a33, #002244);
            border: 2px solid #0066cc;
            border-radius: var(--border-radius);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(14px, 2.5vw, 20px);
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            animation: cellEntry 0.5s ease-out backwards;
            animation-delay: calc(var(--cell-index, 0) * 0.01s);
        }
        
        @keyframes cellEntry {
            from {
                opacity: 0;
                transform: scale(0) rotate(180deg);
            }
            to {
                opacity: 1;
                transform: scale(1) rotate(0deg);
            }
        }
        
        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .cell::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at center, rgba(255,255,255,0.8), transparent);
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s;
        }
        
        .cell:hover:not(.revealed):not(.game-over) {
            transform: translateY(-3px) scale(1.1) rotate(5deg);
            background: linear-gradient(135deg, #003366, #004488);
            border-color: #0ff;
            box-shadow: 0 5px 15px rgba(0,255,255,0.6);
            z-index: 10;
        }
        
        .cell:hover::before {
            left: 100%;
        }
        
        .cell:hover::after {
            opacity: 0.3;
            transform: scale(1.5);
        }
        
        .cell.revealed {
            background: linear-gradient(135deg, rgba(0,100,200,0.3), rgba(0,50,100,0.3));
            border-color: #066;
            transform: scale(0.95);
            animation: revealPop 0.4s ease-out;
        }
        
        @keyframes revealPop {
            0% { 
                transform: scale(0) rotate(360deg); 
                opacity: 0; 
                filter: blur(10px);
            }
            50% { 
                transform: scale(1.2) rotate(180deg); 
                filter: blur(0);
            }
            100% { 
                transform: scale(0.95) rotate(0deg); 
                opacity: 1; 
            }
        }
        
        .cell.mine {
            background: radial-gradient(circle, #ff0066, #990033);
            border-color: #ff0066;
            animation: explode 0.6s ease-out, mineGlow 0.5s ease-out;
        }
        
        @keyframes explode {
            0% { transform: scale(1) rotate(0deg); }
            25% { transform: scale(1.8) rotate(90deg); }
            50% { transform: scale(1.5) rotate(180deg); }
            75% { transform: scale(1.2) rotate(270deg); }
            100% { transform: scale(1) rotate(360deg); }
        }
        
        @keyframes mineGlow {
            0% { box-shadow: 0 0 0 rgba(255,0,102,0.8); }
            50% { box-shadow: 0 0 50px rgba(255,0,102,0.8); }
            100% { box-shadow: 0 0 20px rgba(255,0,102,0.4); }
        }
        
        .cell.flagged::after {
            content: '🚩';
            font-size: clamp(16px, 3vw, 24px);
            animation: flagWave 1s ease-in-out infinite, flagEntry 0.3s ease-out;
            position: absolute;
            opacity: 1;
            transform: scale(1);
        }
        
        @keyframes flagWave {
            0%, 100% { transform: rotate(-5deg) translateY(0); }
            25% { transform: rotate(5deg) translateY(-2px); }
            75% { transform: rotate(-3deg) translateY(1px); }
        }
        
        @keyframes flagEntry {
            from { transform: scale(0) rotate(360deg); }
            to { transform: scale(1) rotate(0deg); }
        }
        
        .cell-1 { color: #0ff; text-shadow: 0 0 10px #0ff; animation: num1Glow 1s ease-in-out infinite; }
        .cell-2 { color: #0f0; text-shadow: 0 0 10px #0f0; animation: num2Glow 1s ease-in-out infinite 0.1s; }
        .cell-3 { color: #ff0; text-shadow: 0 0 10px #ff0; animation: num3Glow 1s ease-in-out infinite 0.2s; }
        .cell-4 { color: #f0f; text-shadow: 0 0 10px #f0f; animation: num4Glow 1s ease-in-out infinite 0.3s; }
        .cell-5 { color: #f66; text-shadow: 0 0 10px #f66; animation: num5Glow 1s ease-in-out infinite 0.4s; }
        .cell-6 { color: #6ff; text-shadow: 0 0 10px #6ff; animation: num6Glow 1s ease-in-out infinite 0.5s; }
        .cell-7 { color: #fff; text-shadow: 0 0 10px #fff; animation: num7Glow 1s ease-in-out infinite 0.6s; }
        .cell-8 { color: #f99; text-shadow: 0 0 10px #f99; animation: num8Glow 1s ease-in-out infinite 0.7s; }
        
        @keyframes num1Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num2Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num3Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num4Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num5Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num6Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num7Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        @keyframes num8Glow { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.5); } }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: clamp(10px, 2vw, 20px);
            margin-top: clamp(20px, 3vw, 30px);
            justify-content: center;
            width: 100%;
            padding: 0 var(--padding-scale);
        }
        
        .cyber-btn {
            padding: clamp(10px, 1.5vw, 15px) clamp(20px, 3vw, 40px);
            background: linear-gradient(135deg, #0066cc, #003366);
            border: 2px solid #0ff;
            border-radius: clamp(8px, 1vw, 10px);
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: clamp(0.9rem, 1.5vw, 1.1rem);
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 clamp(15px, 2vw, 20px) rgba(0,255,255,0.3);
            animation: btnFloat 3s ease-in-out infinite;
            animation-delay: calc(var(--btn-index, 0) * 0.3s);
            flex: 1 1 auto;
            min-width: clamp(100px, 20vw, 150px);
        }
        
        @keyframes btnFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }
        
        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(0,255,255,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .cyber-btn::after {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #0ff, #0f0, #f0f, #0ff);
            border-radius: clamp(8px, 1vw, 10px);
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s;
            animation: btnBorderRotate 2s linear infinite;
        }
        
        @keyframes btnBorderRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .cyber-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 30px rgba(0,255,255,0.7);
            background: linear-gradient(135deg, #0088ff, #004488);
        }
        
        .cyber-btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .cyber-btn:hover::after {
            opacity: 0.5;
        }
        
        .cyber-btn:active {
            transform: translateY(0) scale(0.98);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,20,40,0.98), rgba(0,40,80,0.98));
            border: 3px solid #0ff;
            border-radius: clamp(15px, 2vw, 20px);
            padding: clamp(20px, 3vw, 30px);
            z-index: 100;
            box-shadow: 0 0 clamp(30px, 5vw, 50px) rgba(0,255,255,0.8);
            animation: modalSlide 0.5s ease-out;
            width: var(--modal-width);
            max-height: 90vh;
            overflow-y: auto;
            backdrop-filter: blur(10px);
        }
        
        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translate(-50%, -60%) scale(0.8) rotateX(20deg);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1) rotateX(0deg);
            }
        }
        
        .modal h2 {
            color: #0ff;
            font-size: clamp(1.5rem, 3vw, 2rem);
            margin-bottom: clamp(15px, 2vw, 20px);
            text-align: center;
            text-shadow: 0 0 clamp(15px, 2vw, 20px) rgba(0,255,255,0.8);
            animation: modalTitleGlow 2s ease-in-out infinite;
        }
        
        @keyframes modalTitleGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(0,255,255,0.8); }
            50% { text-shadow: 0 0 30px rgba(0,255,255,1), 0 0 40px rgba(0,255,0,0.5); }
        }
        
        .modal.show {
            display: block;
        }
        
        .difficulty-select {
            display: flex;
            flex-direction: column;
            gap: clamp(10px, 1.5vw, 15px);
            margin-bottom: clamp(15px, 2vw, 20px);
        }
        
        @media (min-width: 480px) {
            .difficulty-select {
                flex-direction: row;
            }
        }
        
        .diff-btn {
            flex: 1;
            padding: clamp(10px, 1.5vw, 15px);
            background: rgba(0,100,200,0.3);
            border: 2px solid #066;
            border-radius: clamp(8px, 1vw, 10px);
            color: #0ff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: var(--font-scale);
            position: relative;
            overflow: hidden;
        }
        
        .diff-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.3), transparent);
            transition: left 0.6s;
        }
        
        .diff-btn:hover {
            background: rgba(0,255,255,0.2);
            border-color: #0ff;
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 5px 20px rgba(0,255,255,0.4);
        }
        
        .diff-btn:hover::before {
            left: 100%;
        }
        
        .diff-btn.selected {
            background: rgba(0,255,255,0.4);
            border-color: #0f0;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
            animation: selectedPulse 1s ease-in-out infinite;
        }
        
        @keyframes selectedPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .particle {
            position: fixed;
            pointer-events: none;
            opacity: 0;
            animation: particleFloat 2s ease-out;
            border-radius: 50%;
            filter: blur(0.5px);
        }
        
        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0);
                filter: blur(0);
            }
            50% {
                opacity: 1;
                transform: translate(var(--x), var(--y)) scale(1);
                filter: blur(0.5px);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--x) * 2), calc(var(--y) * 2)) scale(0.5);
                filter: blur(2px);
            }
        }
        
        .sound-toggle {
            position: fixed;
            top: clamp(15px, 2vw, 20px);
            right: clamp(15px, 2vw, 20px);
            z-index: 100;
            padding: clamp(8px, 1vw, 10px) clamp(15px, 2vw, 20px);
            background: rgba(0,20,40,0.9);
            border: 2px solid #0ff;
            border-radius: clamp(8px, 1vw, 10px);
            color: #0ff;
            cursor: pointer;
            transition: all 0.3s;
            font-size: var(--font-scale);
            backdrop-filter: blur(5px);
            animation: soundBtnFloat 4s ease-in-out infinite;
        }
        
        @keyframes soundBtnFloat {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-3px) rotate(2deg); }
            75% { transform: translateY(3px) rotate(-2deg); }
        }
        
        .sound-toggle:hover {
            background: rgba(0,40,80,0.9);
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 0 20px rgba(0,255,255,0.5);
        }
        
        .sound-toggle.muted {
            color: #666;
            border-color: #666;
            animation: none;
        }
        
        #apiHealthBadge {
            animation: healthPulse 2s ease-in-out infinite;
        }
        
        @keyframes healthPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        /* Enhanced scrollbar for modals */
        .modal::-webkit-scrollbar {
            width: 8px;
        }
        
        .modal::-webkit-scrollbar-track {
            background: rgba(0,20,40,0.5);
            border-radius: 4px;
        }
        
        .modal::-webkit-scrollbar-thumb {
            background: #0ff;
            border-radius: 4px;
        }
        
        .modal::-webkit-scrollbar-thumb:hover {
            background: #0f0;
        }
        
        /* Mobile optimizations */
        @media (max-width: 600px) {
            :root {
                --cell-size: min(8vw, 35px);
                --gap-size: 2px;
            }
            
            .stats-panel {
                gap: clamp(8px, 2vw, 15px);
                padding: clamp(8px, 1.5vw, 12px) clamp(10px, 2vw, 20px);
            }
            
            .cyber-btn {
                font-size: clamp(0.8rem, 2.5vw, 1rem);
                padding: clamp(8px, 2vw, 12px) clamp(15px, 3vw, 30px);
            }
            
            .controls {
                flex-direction: column;
                width: 100%;
                max-width: 300px;
            }
            
            .cyber-btn {
                width: 100%;
            }
        }
        
        /* Tablet optimizations */
        @media (min-width: 601px) and (max-width: 1024px) {
            :root {
                --cell-size: min(4vw, 35px);
            }
        }
        
        /* Large screen optimizations */
        @media (min-width: 1440px) {
            :root {
                --cell-size: 45px;
                --gap-size: 4px;
            }
        }
        
        /* Accessibility - Reduce motion */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        /* Loading spinner */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(0,255,255,0.3);
            border-top-color: #0ff;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Floating background particles */
        .bg-particle {
            position: fixed;
            pointer-events: none;
            opacity: 0.3;
            animation: bgFloat 20s linear infinite;
        }
        
        @keyframes bgFloat {
            from {
                transform: translateY(100vh) rotate(0deg);
            }
            to {
                transform: translateY(-100px) rotate(360deg);
            }
        }
    </style>
</head>
<body>
    <canvas id="three-bg"></canvas>
    
    <div class="sound-toggle" id="soundToggle">
        <span id="soundIcon">🔊</span> SOUND
    </div>
    
    <div class="game-container">
        <h1 class="cyber-title">CyberSweeper 2025</h1>
        
        <div class="stats-panel">
            <div class="stat-box" style="--stat-index: 0">
                <div class="stat-label">Time</div>
                <div class="stat-value" id="timer">000</div>
            </div>
            <div class="stat-box" style="--stat-index: 1">
                <div class="stat-label">Mines</div>
                <div class="stat-value" id="mineCount">10</div>
            </div>
            <div class="stat-box" style="--stat-index: 2">
                <div class="stat-label">Flags</div>
                <div class="stat-value" id="flagCount">0</div>
            </div>
            <div class="stat-box" style="--stat-index: 3">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
        </div>
        
        <div id="game-board">
            <div class="game-grid" id="gameGrid"></div>
        </div>
        
        <div class="controls">
            <button class="cyber-btn" id="newGameBtn" style="--btn-index: 0">NEW GAME</button>
            <button class="cyber-btn" id="difficultyBtn" style="--btn-index: 1">DIFFICULTY</button>
            <button class="cyber-btn" id="highScoresBtn" style="--btn-index: 2">HIGH SCORES</button>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal" id="difficultyModal">
        <h2>SELECT DIFFICULTY</h2>
        <div class="difficulty-select">
            <button class="diff-btn" data-diff="easy">
                <div>EASY</div>
                <div style="font-size: 0.8em; margin-top: 5px;">8x8 • 10 mines</div>
            </button>
            <button class="diff-btn selected" data-diff="medium">
                <div>MEDIUM</div>
                <div style="font-size: 0.8em; margin-top: 5px;">12x12 • 25 mines</div>
            </button>
            <button class="diff-btn" data-diff="hard">
                <div>HARD</div>
                <div style="font-size: 0.8em; margin-top: 5px;">16x16 • 50 mines</div>
            </button>
        </div>
        <button class="cyber-btn" onclick="closeDifficultyModal()">START</button>
    </div>
    
    <div class="modal" id="gameOverModal">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <div style="text-align: center; margin: 20px 0;">
            <div style="font-size: 1.2em; color: #0f0; margin-bottom: 10px;">Final Score</div>
            <div style="font-size: 2em; color: #fff; text-shadow: 0 0 20px #0ff;" id="finalScore">0</div>
        </div>
        <div class="modal-body"></div>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button class="cyber-btn" onclick="newGame()">PLAY AGAIN</button>
            <button class="cyber-btn" onclick="closeGameOverModal()">CLOSE</button>
        </div>
    </div>
    
    <!-- Audio Elements -->
    <audio id="clickSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    <audio id="flagSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    <audio id="explodeSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    <audio id="winSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Enhanced Three.js Background Animation
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-bg'), alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Create blockchain-inspired geometry with variety
        const geometries = [
            new THREE.IcosahedronGeometry(1, 0),
            new THREE.OctahedronGeometry(1, 0),
            new THREE.TetrahedronGeometry(1, 0),
            new THREE.BoxGeometry(1, 1, 1)
        ];
        
        const blocks = [];
        for (let i = 0; i < 25; i++) {
            const geometry = geometries[Math.floor(Math.random() * geometries.length)];
            const material = new THREE.MeshBasicMaterial({ 
                color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 1, 0.5),
                wireframe: true,
                transparent: true,
                opacity: 0.3
            });
            
            const block = new THREE.Mesh(geometry, material);
            block.position.x = (Math.random() - 0.5) * 25;
            block.position.y = (Math.random() - 0.5) * 25;
            block.position.z = (Math.random() - 0.5) * 25;
            block.rotation.x = Math.random() * Math.PI;
            block.rotation.y = Math.random() * Math.PI;
            block.userData = {
                rotSpeed: (Math.random() - 0.5) * 0.02,
                floatSpeed: Math.random() * 0.01 + 0.001,
                floatPhase: Math.random() * Math.PI * 2,
                scaleSpeed: Math.random() * 0.001 + 0.0005
            };
            scene.add(block);
            blocks.push(block);
        }
        
        // Add connecting lines with animation
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, 
            transparent: true, 
            opacity: 0.15 
        });
        
        const lines = [];
        for (let i = 0; i < blocks.length - 1; i++) {
            if (Math.random() > 0.6) {
                const points = [];
                points.push(blocks[i].position);
                points.push(blocks[Math.floor(Math.random() * blocks.length)].position);
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, lineMaterial.clone());
                scene.add(line);
                lines.push(line);
            }
        }
        
        // Add particle system
        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount * 3; i += 3) {
            positions[i] = (Math.random() - 0.5) * 30;
            positions[i + 1] = (Math.random() - 0.5) * 30;
            positions[i + 2] = (Math.random() - 0.5) * 30;
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const particleMaterial = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.1,
            transparent: true,
            opacity: 0.6
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particles);
        
        camera.position.z = 15;
        
        function animateBackground() {
            requestAnimationFrame(animateBackground);
            
            const time = Date.now();
            
            blocks.forEach((block, i) => {
                block.rotation.x += block.userData.rotSpeed;
                block.rotation.y += block.userData.rotSpeed * 0.7;
                block.position.y += Math.sin(time * block.userData.floatSpeed + block.userData.floatPhase) * 0.01;
                
                // Enhanced pulse effect
                const scale = 1 + Math.sin(time * block.userData.scaleSpeed + i) * 0.15;
                block.scale.set(scale, scale, scale);
                
                // Dynamic color shift
                const hue = (time * 0.0001 + block.userData.floatPhase) % 1;
                block.material.color.setHSL(hue, 1, 0.5);
                block.material.opacity = 0.2 + Math.sin(time * 0.001 + i) * 0.1;
            });
            
            // Rotate particle system
            particles.rotation.y += 0.0005;
            particles.rotation.x += 0.0003;
            
            // Animate line opacity
            lines.forEach((line, i) => {
                line.material.opacity = 0.1 + Math.sin(time * 0.001 + i * 0.5) * 0.05;
            });
            
            // Camera subtle movement
            camera.position.x = Math.sin(time * 0.0003) * 2;
            camera.position.y = Math.cos(time * 0.0004) * 2;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }
        
        animateBackground();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        });
        
        // Add floating background particles
        function createBackgroundParticles() {
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'bg-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.width = particle.style.height = Math.random() * 4 + 2 + 'px';
                particle.style.background = `hsl(${180 + Math.random() * 60}, 100%, 50%)`;
                particle.style.borderRadius = '50%';
                particle.style.boxShadow = `0 0 ${Math.random() * 10 + 5}px currentColor`;
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (Math.random() * 10 + 15) + 's';
                document.body.appendChild(particle);
            }
        }
        createBackgroundParticles();
        
        // Enhanced Game Logic
        class CyberSweeper {
            constructor() {
                this.difficulties = {
                    easy: { size: 8, mines: 10 },
                    medium: { size: 12, mines: 25 },
                    hard: { size: 16, mines: 50 }
                };
                this.currentDifficulty = 'medium';
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                this.gameOver = false;
                this.gameWon = false;
                this.timer = 0;
                this.timerInterval = null;
                this.score = 0;
                this.soundEnabled = true;
                this.firstClick = true;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.newGame();
                this.adjustForMobile();
            }
            
            adjustForMobile() {
                // Adjust cell size based on screen size and grid size
                const updateCellSize = () => {
                    const container = document.getElementById('game-board');
                    const maxWidth = Math.min(window.innerWidth * 0.9, 600);
                    const maxHeight = window.innerHeight * 0.6;
                    const diff = this.difficulties[this.currentDifficulty];
                    
                    const cellSize = Math.min(
                        Math.floor(maxWidth / (diff.size + 2)),
                        Math.floor(maxHeight / (diff.size + 2)),
                        40
                    );
                    
                    document.documentElement.style.setProperty('--cell-size', `${cellSize}px`);
                };
                
                updateCellSize();
                window.addEventListener('resize', updateCellSize);
            }
            
            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('difficultyBtn').addEventListener('click', () => this.showDifficultyModal());
                document.getElementById('soundToggle').addEventListener('click', () => this.toggleSound());
                
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectDifficulty(e));
                });
                
                // Touch event support for mobile
                let touchTimer;
                document.addEventListener('touchstart', (e) => {
                    if (e.target.classList.contains('cell')) {
                        touchTimer = setTimeout(() => {
                            this.handleRightClick(e);
                        }, 500);
                    }
                });
                
                document.addEventListener('touchend', () => {
                    clearTimeout(touchTimer);
                });
            }
            
            newGame() {
                const diff = this.difficulties[this.currentDifficulty];
                this.size = diff.size;
                this.mines = diff.mines;
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                this.gameOver = false;
                this.gameWon = false;
                this.timer = 0;
                this.score = 0;
                this.firstClick = true;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                this.initBoard();
                this.renderBoard();
                this.updateStats();
                this.adjustForMobile();
            }
            
            initBoard() {
                // Initialize empty board
                for (let i = 0; i < this.size; i++) {
                    this.board[i] = [];
                    this.revealed[i] = [];
                    this.flagged[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        this.board[i][j] = 0;
                        this.revealed[i][j] = false;
                        this.flagged[i][j] = false;
                    }
                }
            }
            
            placeMines(excludeRow, excludeCol) {
                let placed = 0;
                while (placed < this.mines) {
                    const row = Math.floor(Math.random() * this.size);
                    const col = Math.floor(Math.random() * this.size);
                    
                    // Don't place mine on first click or adjacent cells
                    const isExcluded = Math.abs(row - excludeRow) <= 1 && Math.abs(col - excludeCol) <= 1;
                    
                    if (this.board[row][col] !== -1 && !isExcluded) {
                        this.board[row][col] = -1;
                        placed++;
                        
                        // Update adjacent cells
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const r = row + dr;
                                const c = col + dc;
                                if (r >= 0 && r < this.size && c >= 0 && c < this.size && this.board[r][c] !== -1) {
                                    this.board[r][c]++;
                                }
                            }
                        }
                    }
                }
            }
            
            renderBoard() {
                const grid = document.getElementById('gameGrid');
                grid.innerHTML = '';
                grid.style.gridTemplateColumns = `repeat(${this.size}, var(--cell-size))`;
                
                let cellIndex = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.style.setProperty('--cell-index', cellIndex++);
                        cell.addEventListener('click', (e) => this.handleClick(e));
                        cell.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                        grid.appendChild(cell);
                    }
                }
            }
            
            handleClick(e) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                if (this.gameOver || this.revealed[row][col] || this.flagged[row][col]) return;
                
                if (this.firstClick) {
                    this.placeMines(row, col);
                    this.firstClick = false;
                    this.startTimer();
                }
                
                this.revealCell(row, col);
                this.checkWin();
                this.createParticles(e.target);
                this.playSound('clickSound');
            }
            
            handleRightClick(e) {
                e.preventDefault();
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                if (this.gameOver || this.revealed[row][col]) return;
                
                this.flagged[row][col] = !this.flagged[row][col];
                this.updateCell(row, col);
                this.updateStats();
                this.playSound('flagSound');
                
                // Visual feedback for flag
                e.target.style.animation = 'none';
                setTimeout(() => {
                    e.target.style.animation = '';
                }, 10);
            }
            
            revealCell(row, col) {
                if (row < 0 || row >= this.size || col < 0 || col >= this.size) return;
                if (this.revealed[row][col] || this.flagged[row][col]) return;
                
                this.revealed[row][col] = true;
                this.updateCell(row, col);
                
                if (this.board[row][col] === -1) {
                    this.endGame(false);
                    this.playSound('explodeSound');
                    this.createExplosionEffect(row, col);
                } else {
                    this.score += (this.board[row][col] + 1) * 10;
                    this.updateStats();
                    
                    if (this.board[row][col] === 0) {
                        // Reveal adjacent cells for empty cells with cascade effect
                        setTimeout(() => {
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dc = -1; dc <= 1; dc++) {
                                    this.revealCell(row + dr, col + dc);
                                }
                            }
                        }, 50);
                    }
                }
            }
            
            createExplosionEffect(row, col) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                
                const rect = cell.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top + rect.height / 2;
                
                // Create shockwave
                const shockwave = document.createElement('div');
                shockwave.style.cssText = `
                    position: fixed;
                    left: ${x}px;
                    top: ${y}px;
                    width: 0;
                    height: 0;
                    border: 2px solid #ff0066;
                    border-radius: 50%;
                    transform: translate(-50%, -50%);
                    pointer-events: none;
                    z-index: 1000;
                `;
                document.body.appendChild(shockwave);
                
                // Animate shockwave
                let size = 0;
                const animateShockwave = () => {
                    size += 15;
                    shockwave.style.width = size + 'px';
                    shockwave.style.height = size + 'px';
                    shockwave.style.opacity = Math.max(0, 1 - size / 200);
                    
                    if (size < 200) {
                        requestAnimationFrame(animateShockwave);
                    } else {
                        shockwave.remove();
                    }
                };
                requestAnimationFrame(animateShockwave);
            }
            
            updateCell(row, col) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                
                if (this.revealed[row][col]) {
                    cell.classList.add('revealed');
                    if (this.board[row][col] === -1) {
                        cell.classList.add('mine');
                        cell.textContent = '💣';
                    } else if (this.board[row][col] > 0) {
                        cell.textContent = this.board[row][col];
                        cell.classList.add(`cell-${this.board[row][col]}`);
                    }
                } else if (this.flagged[row][col]) {
                    cell.classList.add('flagged');
                } else {
                    cell.classList.remove('flagged');
                    cell.textContent = '';
                }
            }
            
            checkWin() {
                let cellsToReveal = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] !== -1 && !this.revealed[i][j]) {
                            cellsToReveal++;
                        }
                    }
                }
                
                if (cellsToReveal === 0) {
                    this.endGame(true);
                    this.playSound('winSound');
                    this.createVictoryEffect();
                }
            }
            
            createVictoryEffect() {
                // Create victory particles
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const particle = document.createElement('div');
                        particle.style.cssText = `
                            position: fixed;
                            left: ${Math.random() * window.innerWidth}px;
                            top: ${window.innerHeight}px;
                            width: ${Math.random() * 6 + 4}px;
                            height: ${Math.random() * 6 + 4}px;
                            background: hsl(${Math.random() * 360}, 100%, 50%);
                            border-radius: 50%;
                            pointer-events: none;
                            z-index: 1000;
                            box-shadow: 0 0 10px currentColor;
                        `;
                        document.body.appendChild(particle);
                        
                        // Animate upward
                        let y = window.innerHeight;
                        let x = parseFloat(particle.style.left);
                        let vx = (Math.random() - 0.5) * 5;
                        let vy = -Math.random() * 10 - 10;
                        
                        const animate = () => {
                            y += vy;
                            x += vx;
                            vy += 0.5; // gravity
                            
                            particle.style.top = y + 'px';
                            particle.style.left = x + 'px';
                            particle.style.opacity = Math.max(0, 1 - (window.innerHeight - y) / window.innerHeight);
                            
                            if (y < window.innerHeight) {
                                requestAnimationFrame(animate);
                            } else {
                                particle.remove();
                            }
                        };
                        requestAnimationFrame(animate);
                    }, i * 20);
                }
            }
            
            endGame(won) {
                this.gameOver = true;
                this.gameWon = won;
                clearInterval(this.timerInterval);
                
                // Reveal all mines if lost
                if (!won) {
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            if (this.board[i][j] === -1) {
                                this.revealed[i][j] = true;
                                this.updateCell(i, j);
                            }
                        }
                    }
                }
                
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.add('game-over');
                });
                
                // Show game over modal
                setTimeout(() => {
                    this.showGameOverModal(won);
                }, 1000);
            }
            
            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    document.getElementById('timer').textContent = String(this.timer).padStart(3, '0');
                }, 1000);
            }
            
            updateStats() {
                document.getElementById('mineCount').textContent = this.mines;
                document.getElementById('flagCount').textContent = this.flagged.flat().filter(f => f).length;
                document.getElementById('score').textContent = this.score;
            }
            
            createParticles(element) {
                const rect = element.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top + rect.height / 2;
                
                for (let i = 0; i < 12; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.width = Math.random() * 6 + 2 + 'px';
                    particle.style.height = particle.style.width;
                    particle.style.background = `hsl(${Math.random() * 60 + 180}, 100%, 50%)`;
                    particle.style.boxShadow = `0 0 ${Math.random() * 10 + 5}px currentColor`;
                    
                    const angle = (Math.PI * 2 * i) / 12;
                    const distance = 50 + Math.random() * 50;
                    particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
                    
                    document.body.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 2000);
                }
            }
            
            playSound(soundId) {
                if (!this.soundEnabled) return;
                const sound = document.getElementById(soundId);
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(e => {});
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                const toggle = document.getElementById('soundToggle');
                const icon = document.getElementById('soundIcon');
                
                if (this.soundEnabled) {
                    toggle.classList.remove('muted');
                    icon.textContent = '🔊';
                } else {
                    toggle.classList.add('muted');
                    icon.textContent = '🔇';
                }
            }
            
            showDifficultyModal() {
                document.getElementById('difficultyModal').classList.add('show');
            }
            
            selectDifficulty(e) {
                document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
                e.target.closest('.diff-btn').classList.add('selected');
                this.currentDifficulty = e.target.closest('.diff-btn').dataset.diff;
            }
            
            showGameOverModal(won) {
                const modal = document.getElementById('gameOverModal');
                const title = document.getElementById('gameOverTitle');
                const finalScore = document.getElementById('finalScore');
                
                title.textContent = won ? 'VICTORY!' : 'GAME OVER';
                title.style.color = won ? '#0f0' : '#f00';
                
                const bonus = won ? 1000 : 0;
                const timeBonus = Math.max(0, 500 - this.timer * 2);
                const totalScore = this.score + bonus + timeBonus;
                
                finalScore.textContent = totalScore;
                
                modal.classList.add('show');
            }
        }
        
        // Global functions for modal controls
        function closeDifficultyModal() {
            document.getElementById('difficultyModal').classList.remove('show');
            game.newGame();
        }
        
        function closeGameOverModal() {
            document.getElementById('gameOverModal').classList.remove('show');
        }
        
        function newGame() {
            closeGameOverModal();
            game.newGame();
        }
        
        // Initialize game
        const game = new CyberSweeper();

// ======== CYBERSWEEPER ↔ FLASK API INTEGRATION ========
(() => {
  // ---------- Config ----------
  const API_BASE = (window.API_BASE || 'https://pserver.burtoncummings.io').replace(/\/+$/,'');
  const TIMEOUT_MS = 10000;

  // ---------- Fetch helper with timeout ----------
  async function apiFetch(path, {method='GET', body, headers} = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
    try {
      const res = await fetch(`${API_BASE}${path}`, {
        method,
        headers: {
          'Accept': 'application/json',
          ...(body ? {'Content-Type':'application/json'} : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
        credentials: 'omit',
        mode: 'cors'
      });
      const isJson = res.headers.get('content-type')?.includes('application/json');
      const data = isJson ? await res.json() : await res.text();
      if (!res.ok) {
        const msg = (isJson && data?.error) ? data.error : `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return data;
    } finally { clearTimeout(t); }
  }

  // ---------- API surface ----------
  const api = {
    health: () => apiFetch('/api/health'),
    highScores: (difficulty='all', limit=10) =>
      apiFetch(`/api/minesweep/high_scores?difficulty=${encodeURIComponent(difficulty)}&limit=${limit}`),
    saveHighScore: (payload) => apiFetch('/api/minesweep/high_scores', {method:'POST', body: payload}),
    stats: () => apiFetch('/api/minesweep/statistics'),
    daily: () => apiFetch('/api/minesweep/daily_challenge'),
    validate: (payload) => apiFetch('/api/minesweep/validate_game', {method:'POST', body: payload}),
  };

  // ---------- Status badge  ----------
  (function addHealthBadge(){
    const badge = document.createElement('div');
    badge.id = 'apiHealthBadge';
    badge.style.cssText = `
      position:fixed; left:20px; top:20px; z-index:100;
      padding:8px 12px; border:2px solid #0ff; border-radius:10px;
      background:rgba(0,20,40,0.9); color:#0ff; font-size:.85rem;
      backdrop-filter: blur(5px);`;
    badge.textContent = 'API: checking…';
    document.body.appendChild(badge);
    api.health().then(()=> {
      badge.style.color = '#0f0';
      badge.textContent = 'API: online';
    }).catch(()=>{
      badge.style.color = '#f66';
      badge.textContent = 'API: offline';
    });
  })();

  // ---------- WebAudio micro-SFX ----------
  const sfx = (() => {
    let ctx;
    function ensureCtx(){
      if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === 'suspended') ctx.resume().catch(()=>{});
      return ctx;
    }
    function tone(freq=440, dur=0.07, type='square', gain=0.03){
      const ac = ensureCtx();
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g).connect(ac.destination);
      const now = ac.currentTime;
      o.start(now);
      o.stop(now + dur);
      // quick click envelope
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(gain, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    }
    const presets = {
      click: ()=> tone(880, 0.04, 'square', 0.02),
      flag:  ()=> tone(660, 0.06, 'triangle', 0.025),
      explode: ()=>{
        const ac = ensureCtx();
        const n = ac.createBufferSource();
        const buf = ac.createBuffer(1, ac.sampleRate * 0.25, ac.sampleRate);
        const data = buf.getChannelData(0);
        for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * (1 - i/data.length); // noise w/ decay
        const g = ac.createGain();
        g.gain.value = 0.06;
        n.buffer = buf; n.connect(g).connect(ac.destination);
        n.start();
      },
      win:   ()=>{
        tone(880, 0.08, 'sine', 0.03);
        setTimeout(()=>tone(1175,0.08,'sine',0.03), 90);
        setTimeout(()=>tone(1568,0.10,'sine',0.03), 180);
      }
    };
    return { play(name){ presets[name]?.(); } };
  })();

  // ---------- Small UI helpers ----------
  function ensureModal(id, titleText) {
    let modal = document.getElementById(id);
    if (!modal) {
      modal = document.createElement('div');
      modal.id = id;
      modal.className = 'modal';
      modal.innerHTML = `
        <h2>${titleText}</h2>
        <div class="modal-body" style="max-height:50vh; overflow:auto;"></div>
        <div style="display:flex; gap:12px; justify-content:center; margin-top:16px; flex-wrap:wrap;">
          <button class="cyber-btn" data-close>Close</button>
        </div>`;
      document.body.appendChild(modal);
      modal.querySelector('[data-close]').addEventListener('click', ()=> modal.classList.remove('show'));
    }
    return modal;
  }

 // ---------- Hook the game instance ---------
  if (!game._integratedApi) {
    game._integratedApi = true;
    game.moves = [];

    const originalHandleClick = game.handleClick.bind(game);
    const originalHandleRight  = game.handleRightClick.bind(game);
    const originalNewGame      = game.newGame.bind(game);
    const originalShowGameOver = game.showGameOverModal.bind(game);

    // Replace sound system to use WebAudio tones
    const soundMap = { clickSound:'click', flagSound:'flag', explodeSound:'explode', winSound:'win' };
    game.playSound = function(soundId){
      if (!this.soundEnabled) return;
      sfx.play(soundMap[soundId] || 'click');
    };

    game.newGame = function() {
      this.moves = [];
      originalNewGame();
    };
    game.handleClick = function(e) {
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      this.moves.push({t: Date.now(), type:'reveal', row, col});
      return originalHandleClick(e);
    };
    game.handleRightClick = function(e) {
      e.preventDefault(); // ensure no native context menu
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      this.moves.push({t: Date.now(), type:'flag', row, col});
      return originalHandleRight(e);
    };

    function snapshotBoard(ctx) {
      const out = [];
      for (let r=0; r<ctx.size; r++) {
        const row = [];
        for (let c=0; c<ctx.size; c++) {
          row.push({ v: ctx.board[r][c], rev: !!ctx.revealed[r][c], flg: !!ctx.flagged[r][c] });
        }
        out.push(row);
      }
      return out;
    }

    game.showGameOverModal = function(won) {
      // call the original to show the modal + score
      originalShowGameOver(won);

      const modal = document.getElementById('gameOverModal');
      if (!modal) { console.warn('No #gameOverModal found'); return; }

      // Prefer a dedicated container; otherwise append to modal root
      const container = modal.querySelector('.modal-body') || modal;

      // remove any previous form
      document.getElementById('scoreSubmitBox')?.remove();

      // --- if you want the form only on WIN, leave this check ---
      // if (!won) return;

      // --- if you want the form on ANY game over (win or lose), comment out the line above ---

      // Build the form
      const boxEl = document.createElement('div');
      boxEl.id = 'scoreSubmitBox';
      boxEl.style.cssText = 'margin-top:16px; display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap;';
      boxEl.innerHTML = `
        <div style="color:#0ff; font-size:0.95rem;">Save your score:</div>
        <input id="initialsInput" maxlength="3" placeholder="ABC"
               style="text-transform:uppercase; padding:10px; border:2px solid #0ff; border-radius:10px; background:rgba(0,20,40,.7); color:#fff; width:80px; text-align:center; font-family:Orbitron,monospace;">
        <button class="cyber-btn" id="submitScoreBtn">Submit</button>
        <div id="submitScoreMsg" style="width:100%; text-align:center; color:#aaa; font-size:.85rem; margin-top:6px;"></div>
      `;
      container.appendChild(boxEl);

      document.getElementById('submitScoreBtn').onclick = async () => {
        const initials = (document.getElementById('initialsInput').value || '')
                          .toUpperCase().replace(/[^A-Z]/g,'').slice(0,3);
        const msg = document.getElementById('submitScoreMsg');
        if (initials.length !== 3) { msg.style.color = '#f77'; msg.textContent = 'Please enter exactly 3 letters.'; return; }

        const timeTaken = this.timer|0;
        const savePayload = {
          initials,
          score: parseInt(document.getElementById('finalScore').textContent,10) || this.score,
          time: timeTaken,
          difficulty: this.currentDifficulty,
          grid_size: this.size,
          mines_count: this.mines
        };

        msg.style.color = '#0ff';
        msg.textContent = 'Saving score…';
        console.debug('Saving high score payload:', savePayload);

        try {
          // If you still call validate(), your server already returns valid: true — OK to skip.
          // await api.validate({ moves: this.moves.slice(0,1000), time: timeTaken, board: snapshotBoard(this) });

          const saved = await api.saveHighScore(savePayload);
          console.debug('Save response:', saved);
          msg.style.color = '#0f0';
          msg.textContent = `Saved! Rank #${saved?.rank || '?'} — opening leaderboard…`;
          showHighScoresModal(this.currentDifficulty);
        } catch (e) {
          console.error('Save failed:', e);
          msg.style.color = '#f77';
          msg.textContent = `Save failed: ${e.message}`;
        }
      };
    };
  }

  // ---------- High Scores Modal + Button wiring ----------
  function ensureHighScoresTable(modalBody, items=[]) {
    if (!items.length) {
      modalBody.innerHTML = `<div style="text-align:center; color:#aaa;">No scores yet.</div>`;
      return;
    }
    const table = document.createElement('table');
    table.style.cssText = `width:100%; border-collapse:collapse; font-size:.95rem;`;
    table.innerHTML = `
      <thead>
        <tr>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">#</th>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">Initials</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #0ff;">Score</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #0ff;">Time (s)</th>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">Diff</th>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">When</th>
        </tr>
      </thead>
      <tbody></tbody>`;
    const tb = table.querySelector('tbody');
    items.forEach((row, i) => {
      const tr = document.createElement('tr');
      const when = row.created_at ? new Date(row.created_at).toLocaleString() : '';
      tr.innerHTML = `
        <td style="padding:8px;">${i+1}</td>
        <td style="padding:8px;">${row.initials || ''}</td>
        <td style="padding:8px; text-align:right;">${row.score?.toLocaleString?.() ?? row.score}</td>
        <td style="padding:8px; text-align:right;">${row.time}</td>
        <td style="padding:8px;">${row.difficulty}</td>
        <td style="padding:8px;">${when}</td>`;
      tb.appendChild(tr);
    });
    modalBody.innerHTML = '';
    modalBody.appendChild(table);
  }

  async function showHighScoresModal(difficulty='all') {
    const modal = ensureModal('highScoresModal', 'HIGH SCORES');
    const body = modal.querySelector('.modal-body');
    body.innerHTML = `<div style="text-align:center; color:#0ff;">Loading…</div>`;
    modal.classList.add('show');
    try {
      const res = await api.highScores(difficulty, 10);
      ensureHighScoresTable(body, res?.high_scores || []);
    } catch (e) {
      body.innerHTML = `<div style="color:#f77;">Failed to load: ${e.message}</div>`;
    }
  }

  document.getElementById('highScoresBtn')?.addEventListener('click', () => {
    const diff = game.currentDifficulty || 'all';
    showHighScoresModal(diff);
  });

  // ---------- Optional background fetches ----------
  (async () => {
    try { await api.stats(); } catch {}
    try { await api.daily(); } catch {}
  })();

  // ---------- Expose for debugging ----------
  window.CyberAPI = { api, showHighScoresModal };
})();

    </script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/games/ms_sw.js', { scope: '/games/' })
        .catch(err => console.warn('SW reg failed:', err));
    });
  }
  // (Optional) "Add to Home Screen" UX hook
  window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    window.deferredPrompt = e; // call deferredPrompt.prompt() from a custom button if you want
  });
</script>
</body>
</html>
