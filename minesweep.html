<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CyberSweeper 2025 - Blockchain Arcade Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: #000;
            color: #0ff;
            overflow: hidden;
            position: relative;
            min-height: 100vh;
        }
        
        #three-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .game-container {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
            background: radial-gradient(ellipse at center, rgba(0,255,255,0.05) 0%, transparent 70%);
        }
        
        .cyber-title {
            font-size: 3.5em;
            font-weight: 900;
            text-transform: uppercase;
            background: linear-gradient(45deg, #0ff, #0f0, #f0f);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0,255,255,0.8);
            animation: glitch 2s infinite;
            margin-bottom: 20px;
        }
        
        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
        }
        
        .stats-panel {
            display: flex;
            gap: 30px;
            margin-bottom: 20px;
            padding: 15px 30px;
            background: rgba(0,20,40,0.8);
            border: 2px solid #0ff;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0,255,255,0.5), inset 0 0 20px rgba(0,255,255,0.1);
        }
        
        .stat-box {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .stat-label {
            font-size: 0.8em;
            color: #0f0;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px currentColor;
        }
        
        #game-board {
            position: relative;
            padding: 20px;
            background: linear-gradient(135deg, rgba(0,50,100,0.9), rgba(0,20,40,0.9));
            border: 3px solid #0ff;
            border-radius: 20px;
            box-shadow: 
                0 0 50px rgba(0,255,255,0.7),
                inset 0 0 30px rgba(0,255,255,0.2),
                0 10px 30px rgba(0,0,0,0.8);
            animation: boardPulse 3s ease-in-out infinite;
        }
        
        @keyframes boardPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }
        
        .game-grid {
            display: grid;
            gap: 3px;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            border-radius: 10px;
        }
        
        .cell {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #001a33, #002244);
            border: 2px solid #0066cc;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .cell::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0,255,255,0.4), transparent);
            transition: left 0.5s;
        }
        
        .cell:hover:not(.revealed):not(.game-over) {
            transform: translateY(-3px) scale(1.1);
            background: linear-gradient(135deg, #003366, #004488);
            border-color: #0ff;
            box-shadow: 0 5px 15px rgba(0,255,255,0.6);
        }
        
        .cell:hover::before {
            left: 100%;
        }
        
        .cell.revealed {
            background: linear-gradient(135deg, rgba(0,100,200,0.3), rgba(0,50,100,0.3));
            border-color: #066;
            transform: scale(0.95);
            animation: revealPop 0.4s ease-out;
        }
        
        @keyframes revealPop {
            0% { transform: scale(0); opacity: 0; }
            50% { transform: scale(1.2); }
            100% { transform: scale(0.95); opacity: 1; }
        }
        
        .cell.mine {
            background: radial-gradient(circle, #ff0066, #990033);
            border-color: #ff0066;
            animation: explode 0.6s ease-out;
        }
        
        @keyframes explode {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.5) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }
        
        .cell.flagged::after {
            content: 'ðŸš©';
            font-size: 24px;
            animation: flagWave 1s ease-in-out infinite;
        }
        
        @keyframes flagWave {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }
        
        .cell-1 { color: #0ff; text-shadow: 0 0 10px #0ff; }
        .cell-2 { color: #0f0; text-shadow: 0 0 10px #0f0; }
        .cell-3 { color: #ff0; text-shadow: 0 0 10px #ff0; }
        .cell-4 { color: #f0f; text-shadow: 0 0 10px #f0f; }
        .cell-5 { color: #f66; text-shadow: 0 0 10px #f66; }
        .cell-6 { color: #6ff; text-shadow: 0 0 10px #6ff; }
        .cell-7 { color: #fff; text-shadow: 0 0 10px #fff; }
        .cell-8 { color: #f99; text-shadow: 0 0 10px #f99; }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 30px;
        }
        
        .cyber-btn {
            padding: 15px 40px;
            background: linear-gradient(135deg, #0066cc, #003366);
            border: 2px solid #0ff;
            border-radius: 10px;
            color: #fff;
            font-family: 'Orbitron', monospace;
            font-size: 1.1em;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0,255,255,0.3);
        }
        
        .cyber-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(0,255,255,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }
        
        .cyber-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 30px rgba(0,255,255,0.7);
            background: linear-gradient(135deg, #0088ff, #004488);
        }
        
        .cyber-btn:hover::before {
            width: 300px;
            height: 300px;
        }
        
        .cyber-btn:active {
            transform: translateY(0);
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0,20,40,0.95), rgba(0,40,80,0.95));
            border: 3px solid #0ff;
            border-radius: 20px;
            padding: 30px;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0,255,255,0.8);
            animation: modalSlide 0.5s ease-out;
        }
        
        @keyframes modalSlide {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .modal h2 {
            color: #0ff;
            font-size: 2em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 20px rgba(0,255,255,0.8);
        }
        
        .modal.show {
            display: block;
        }
        
        .difficulty-select {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .diff-btn {
            flex: 1;
            padding: 15px;
            background: rgba(0,100,200,0.3);
            border: 2px solid #066;
            border-radius: 10px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .diff-btn:hover {
            background: rgba(0,255,255,0.2);
            border-color: #0ff;
            transform: scale(1.05);
        }
        
        .diff-btn.selected {
            background: rgba(0,255,255,0.4);
            border-color: #0f0;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }
        
        .particle {
            position: absolute;
            pointer-events: none;
            opacity: 0;
            animation: particleFloat 2s ease-out;
        }
        
        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(0);
            }
            50% {
                opacity: 1;
                transform: translate(var(--x), var(--y)) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--x) * 2), calc(var(--y) * 2)) scale(0.5);
            }
        }
        
        .sound-toggle {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
            padding: 10px 20px;
            background: rgba(0,20,40,0.8);
            border: 2px solid #0ff;
            border-radius: 10px;
            color: #0ff;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .sound-toggle:hover {
            background: rgba(0,40,80,0.8);
            transform: scale(1.1);
        }
        
        .sound-toggle.muted {
            color: #666;
            border-color: #666;
        }
    </style>
</head>
<body>
    <canvas id="three-bg"></canvas>
    
    <div class="sound-toggle" id="soundToggle">
        <span id="soundIcon">ðŸ”Š</span> SOUND
    </div>
    
    <div class="game-container">
        <h1 class="cyber-title">CyberSweeper 2025</h1>
        
        <div class="stats-panel">
            <div class="stat-box">
                <div class="stat-label">Time</div>
                <div class="stat-value" id="timer">000</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Mines</div>
                <div class="stat-value" id="mineCount">10</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Flags</div>
                <div class="stat-value" id="flagCount">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
        </div>
        
        <div id="game-board">
            <div class="game-grid" id="gameGrid"></div>
        </div>
        
        <div class="controls">
            <button class="cyber-btn" id="newGameBtn">NEW GAME</button>
            <button class="cyber-btn" id="difficultyBtn">DIFFICULTY</button>
            <button class="cyber-btn" id="highScoresBtn">HIGH SCORES</button>
        </div>
    </div>
    
    <!-- Modals -->
    <div class="modal" id="difficultyModal">
        <h2>SELECT DIFFICULTY</h2>
        <div class="difficulty-select">
            <button class="diff-btn" data-diff="easy">
                <div>EASY</div>
                <div style="font-size: 0.8em; margin-top: 5px;">8x8 â€¢ 10 mines</div>
            </button>
            <button class="diff-btn selected" data-diff="medium">
                <div>MEDIUM</div>
                <div style="font-size: 0.8em; margin-top: 5px;">12x12 â€¢ 25 mines</div>
            </button>
            <button class="diff-btn" data-diff="hard">
                <div>HARD</div>
                <div style="font-size: 0.8em; margin-top: 5px;">16x16 â€¢ 50 mines</div>
            </button>
        </div>
        <button class="cyber-btn" onclick="closeDifficultyModal()">START</button>
    </div>
    
    <div class="modal" id="gameOverModal">
        <h2 id="gameOverTitle">GAME OVER</h2>
        <div style="text-align: center; margin: 20px 0;">
            <div style="font-size: 1.2em; color: #0f0; margin-bottom: 10px;">Final Score</div>
            <div style="font-size: 2em; color: #fff; text-shadow: 0 0 20px #0ff;" id="finalScore">0</div>
        </div>
        <div style="display: flex; gap: 15px;">
            <button class="cyber-btn" onclick="newGame()">PLAY AGAIN</button>
            <button class="cyber-btn" onclick="closeGameOverModal()">CLOSE</button>
        </div>
    </div>
    
    <!-- Audio Elements -->
    <audio id="clickSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    <audio id="flagSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    <audio id="explodeSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    <audio id="winSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" type="audio/wav">
    </audio>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js Background Animation
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('three-bg'), alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Create blockchain-inspired geometry
        const geometry = new THREE.IcosahedronGeometry(1, 0);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x00ffff, 
            wireframe: true,
            transparent: true,
            opacity: 0.3
        });
        
        const blocks = [];
        for (let i = 0; i < 20; i++) {
            const block = new THREE.Mesh(geometry, material.clone());
            block.position.x = (Math.random() - 0.5) * 20;
            block.position.y = (Math.random() - 0.5) * 20;
            block.position.z = (Math.random() - 0.5) * 20;
            block.rotation.x = Math.random() * Math.PI;
            block.rotation.y = Math.random() * Math.PI;
            block.userData = {
                rotSpeed: (Math.random() - 0.5) * 0.02,
                floatSpeed: Math.random() * 0.01 + 0.001,
                floatPhase: Math.random() * Math.PI * 2
            };
            scene.add(block);
            blocks.push(block);
        }
        
        // Add lines connecting blocks
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: 0x00ff00, 
            transparent: true, 
            opacity: 0.1 
        });
        
        for (let i = 0; i < blocks.length - 1; i++) {
            if (Math.random() > 0.7) {
                const points = [];
                points.push(blocks[i].position);
                points.push(blocks[i + 1].position);
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
            }
        }
        
        camera.position.z = 15;
        
        function animateBackground() {
            requestAnimationFrame(animateBackground);
            
            blocks.forEach(block => {
                block.rotation.x += block.userData.rotSpeed;
                block.rotation.y += block.userData.rotSpeed * 0.7;
                block.position.y += Math.sin(Date.now() * block.userData.floatSpeed + block.userData.floatPhase) * 0.01;
                
                // Pulse effect
                const scale = 1 + Math.sin(Date.now() * 0.001) * 0.1;
                block.scale.set(scale, scale, scale);
                
                // Color shift
                const hue = (Date.now() * 0.0001 + block.userData.floatPhase) % 1;
                block.material.color.setHSL(hue, 1, 0.5);
            });
            
            renderer.render(scene, camera);
        }
        
        animateBackground();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Game Logic
        class CyberSweeper {
            constructor() {
                this.difficulties = {
                    easy: { size: 8, mines: 10 },
                    medium: { size: 12, mines: 25 },
                    hard: { size: 16, mines: 50 }
                };
                this.currentDifficulty = 'medium';
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                this.gameOver = false;
                this.gameWon = false;
                this.timer = 0;
                this.timerInterval = null;
                this.score = 0;
                this.soundEnabled = true;
                this.firstClick = true;
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                this.newGame();
            }
            
            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('difficultyBtn').addEventListener('click', () => this.showDifficultyModal());
                document.getElementById('soundToggle').addEventListener('click', () => this.toggleSound());
                
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.selectDifficulty(e));
                });
            }
            
            newGame() {
                const diff = this.difficulties[this.currentDifficulty];
                this.size = diff.size;
                this.mines = diff.mines;
                this.board = [];
                this.revealed = [];
                this.flagged = [];
                this.gameOver = false;
                this.gameWon = false;
                this.timer = 0;
                this.score = 0;
                this.firstClick = true;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                this.initBoard();
                this.renderBoard();
                this.updateStats();
            }
            
            initBoard() {
                // Initialize empty board
                for (let i = 0; i < this.size; i++) {
                    this.board[i] = [];
                    this.revealed[i] = [];
                    this.flagged[i] = [];
                    for (let j = 0; j < this.size; j++) {
                        this.board[i][j] = 0;
                        this.revealed[i][j] = false;
                        this.flagged[i][j] = false;
                    }
                }
            }
            
            placeMines(excludeRow, excludeCol) {
                let placed = 0;
                while (placed < this.mines) {
                    const row = Math.floor(Math.random() * this.size);
                    const col = Math.floor(Math.random() * this.size);
                    
                    // Don't place mine on first click or adjacent cells
                    const isExcluded = Math.abs(row - excludeRow) <= 1 && Math.abs(col - excludeCol) <= 1;
                    
                    if (this.board[row][col] !== -1 && !isExcluded) {
                        this.board[row][col] = -1;
                        placed++;
                        
                        // Update adjacent cells
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const r = row + dr;
                                const c = col + dc;
                                if (r >= 0 && r < this.size && c >= 0 && c < this.size && this.board[r][c] !== -1) {
                                    this.board[r][c]++;
                                }
                            }
                        }
                    }
                }
            }
            
            renderBoard() {
                const grid = document.getElementById('gameGrid');
                grid.innerHTML = '';
                grid.style.gridTemplateColumns = `repeat(${this.size}, 40px)`;
                
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.addEventListener('click', (e) => this.handleClick(e));
                        cell.addEventListener('contextmenu', (e) => this.handleRightClick(e));
                        grid.appendChild(cell);
                    }
                }
            }
            
            handleClick(e) {
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                if (this.gameOver || this.revealed[row][col] || this.flagged[row][col]) return;
                
                if (this.firstClick) {
                    this.placeMines(row, col);
                    this.firstClick = false;
                    this.startTimer();
                }
                
                this.revealCell(row, col);
                this.checkWin();
                this.createParticles(e.target);
                this.playSound('clickSound');
            }
            
            handleRightClick(e) {
                e.preventDefault();
                const row = parseInt(e.target.dataset.row);
                const col = parseInt(e.target.dataset.col);
                
                if (this.gameOver || this.revealed[row][col]) return;
                
                this.flagged[row][col] = !this.flagged[row][col];
                this.updateCell(row, col);
                this.updateStats();
                this.playSound('flagSound');
            }
            
            revealCell(row, col) {
                if (row < 0 || row >= this.size || col < 0 || col >= this.size) return;
                if (this.revealed[row][col] || this.flagged[row][col]) return;
                
                this.revealed[row][col] = true;
                this.updateCell(row, col);
                
                if (this.board[row][col] === -1) {
                    this.endGame(false);
                    this.playSound('explodeSound');
                } else {
                    this.score += (this.board[row][col] + 1) * 10;
                    this.updateStats();
                    
                    if (this.board[row][col] === 0) {
                        // Reveal adjacent cells for empty cells
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                this.revealCell(row + dr, col + dc);
                            }
                        }
                    }
                }
            }
            
            updateCell(row, col) {
                const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
                if (!cell) return;
                
                if (this.revealed[row][col]) {
                    cell.classList.add('revealed');
                    if (this.board[row][col] === -1) {
                        cell.classList.add('mine');
                        cell.textContent = 'ðŸ’£';
                    } else if (this.board[row][col] > 0) {
                        cell.textContent = this.board[row][col];
                        cell.classList.add(`cell-${this.board[row][col]}`);
                    }
                } else if (this.flagged[row][col]) {
                    cell.classList.add('flagged');
                } else {
                    cell.classList.remove('flagged');
                    cell.textContent = '';
                }
            }
            
            checkWin() {
                let cellsToReveal = 0;
                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] !== -1 && !this.revealed[i][j]) {
                            cellsToReveal++;
                        }
                    }
                }
                
                if (cellsToReveal === 0) {
                    this.endGame(true);
                    this.playSound('winSound');
                }
            }
            
            endGame(won) {
                this.gameOver = true;
                this.gameWon = won;
                clearInterval(this.timerInterval);
                
                // Reveal all mines if lost
                if (!won) {
                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            if (this.board[i][j] === -1) {
                                this.revealed[i][j] = true;
                                this.updateCell(i, j);
                            }
                        }
                    }
                }
                
                document.querySelectorAll('.cell').forEach(cell => {
                    cell.classList.add('game-over');
                });
                
                // Show game over modal
                setTimeout(() => {
                    this.showGameOverModal(won);
                }, 1000);
            }
            
            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    document.getElementById('timer').textContent = String(this.timer).padStart(3, '0');
                }, 1000);
            }
            
            updateStats() {
                document.getElementById('mineCount').textContent = this.mines;
                document.getElementById('flagCount').textContent = this.flagged.flat().filter(f => f).length;
                document.getElementById('score').textContent = this.score;
            }
            
            createParticles(element) {
                const rect = element.getBoundingClientRect();
                const x = rect.left + rect.width / 2;
                const y = rect.top + rect.height / 2;
                
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = x + 'px';
                    particle.style.top = y + 'px';
                    particle.style.width = '4px';
                    particle.style.height = '4px';
                    particle.style.background = `hsl(${Math.random() * 60 + 180}, 100%, 50%)`;
                    particle.style.borderRadius = '50%';
                    particle.style.boxShadow = `0 0 6px currentColor`;
                    
                    const angle = (Math.PI * 2 * i) / 8;
                    const distance = 50 + Math.random() * 50;
                    particle.style.setProperty('--x', `${Math.cos(angle) * distance}px`);
                    particle.style.setProperty('--y', `${Math.sin(angle) * distance}px`);
                    
                    document.body.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 2000);
                }
            }
            
            playSound(soundId) {
                if (!this.soundEnabled) return;
                const sound = document.getElementById(soundId);
                if (sound) {
                    sound.currentTime = 0;
                    sound.play().catch(e => {});
                }
            }
            
            toggleSound() {
                this.soundEnabled = !this.soundEnabled;
                const toggle = document.getElementById('soundToggle');
                const icon = document.getElementById('soundIcon');
                
                if (this.soundEnabled) {
                    toggle.classList.remove('muted');
                    icon.textContent = 'ðŸ”Š';
                } else {
                    toggle.classList.add('muted');
                    icon.textContent = 'ðŸ”‡';
                }
            }
            
            showDifficultyModal() {
                document.getElementById('difficultyModal').classList.add('show');
            }
            
            selectDifficulty(e) {
                document.querySelectorAll('.diff-btn').forEach(btn => btn.classList.remove('selected'));
                e.target.closest('.diff-btn').classList.add('selected');
                this.currentDifficulty = e.target.closest('.diff-btn').dataset.diff;
            }
            
            showGameOverModal(won) {
                const modal = document.getElementById('gameOverModal');
                const title = document.getElementById('gameOverTitle');
                const finalScore = document.getElementById('finalScore');
                
                title.textContent = won ? 'VICTORY!' : 'GAME OVER';
                title.style.color = won ? '#0f0' : '#f00';
                
                const bonus = won ? 1000 : 0;
                const timeBonus = Math.max(0, 500 - this.timer * 2);
                const totalScore = this.score + bonus + timeBonus;
                
                finalScore.textContent = totalScore;
                
                modal.classList.add('show');
            }
        }
        
        // Global functions for modal controls
        function closeDifficultyModal() {
            document.getElementById('difficultyModal').classList.remove('show');
            game.newGame();
        }
        
        function closeGameOverModal() {
            document.getElementById('gameOverModal').classList.remove('show');
        }
        
        function newGame() {
            closeGameOverModal();
            game.newGame();
        }
        
        // Initialize game
        const game = new CyberSweeper();

// ======== CYBERSWEEPER â†” FLASK API INTEGRATION (fixed) ========
(() => {
  // ---------- Config ----------
  const API_BASE = (window.API_BASE || 'https://pserver.burtoncummings.io').replace(/\/+$/,'');
  const TIMEOUT_MS = 10000;

  // ---------- Fetch helper with timeout ----------
  async function apiFetch(path, {method='GET', body, headers} = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
    try {
      const res = await fetch(`${API_BASE}${path}`, {
        method,
        headers: {
          'Accept': 'application/json',
          ...(body ? {'Content-Type':'application/json'} : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
        credentials: 'omit',
        mode: 'cors'
      });
      const isJson = res.headers.get('content-type')?.includes('application/json');
      const data = isJson ? await res.json() : await res.text();
      if (!res.ok) {
        const msg = (isJson && data?.error) ? data.error : `HTTP ${res.status}`;
        throw new Error(msg);
      }
      return data;
    } finally { clearTimeout(t); }
  }

  // ---------- API surface ----------
  const api = {
    health: () => apiFetch('/api/health'),
    highScores: (difficulty='all', limit=10) =>
      apiFetch(`/api/minesweep/high_scores?difficulty=${encodeURIComponent(difficulty)}&limit=${limit}`),
    saveHighScore: (payload) => apiFetch('/api/minesweep/high_scores', {method:'POST', body: payload}),
    stats: () => apiFetch('/api/minesweep/statistics'),
    daily: () => apiFetch('/api/minesweep/daily_challenge'),
    validate: (payload) => apiFetch('/api/minesweep/validate_game', {method:'POST', body: payload}),
  };

  // ---------- Status badge (health check) ----------
  // (Moved AFTER api is defined to avoid TDZ error)
  (function addHealthBadge(){
    const badge = document.createElement('div');
    badge.id = 'apiHealthBadge';
    badge.style.cssText = `
      position:fixed; left:20px; top:20px; z-index:100;
      padding:8px 12px; border:2px solid #0ff; border-radius:10px;
      background:rgba(0,20,40,0.8); color:#0ff; font-size:.85rem;`;
    badge.textContent = 'API: checkingâ€¦';
    document.body.appendChild(badge);
    api.health().then(()=> {
      badge.style.color = '#0f0';
      badge.textContent = 'API: online';
    }).catch(()=>{
      badge.style.color = '#f66';
      badge.textContent = 'API: offline';
    });
  })();

  // ---------- WebAudio micro-SFX (replaces broken <audio> base64) ----------
  const sfx = (() => {
    let ctx;
    function ensureCtx(){
      if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === 'suspended') ctx.resume().catch(()=>{});
      return ctx;
    }
    function tone(freq=440, dur=0.07, type='square', gain=0.03){
      const ac = ensureCtx();
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g).connect(ac.destination);
      const now = ac.currentTime;
      o.start(now);
      o.stop(now + dur);
      // quick click envelope
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(gain, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    }
    const presets = {
      click: ()=> tone(880, 0.04, 'square', 0.02),
      flag:  ()=> tone(660, 0.06, 'triangle', 0.025),
      explode: ()=>{
        const ac = ensureCtx();
        const n = ac.createBufferSource();
        const buf = ac.createBuffer(1, ac.sampleRate * 0.25, ac.sampleRate);
        const data = buf.getChannelData(0);
        for (let i=0; i<data.length; i++) data[i] = (Math.random()*2-1) * (1 - i/data.length); // noise w/ decay
        const g = ac.createGain();
        g.gain.value = 0.06;
        n.buffer = buf; n.connect(g).connect(ac.destination);
        n.start();
      },
      win:   ()=>{
        tone(880, 0.08, 'sine', 0.03);
        setTimeout(()=>tone(1175,0.08,'sine',0.03), 90);
        setTimeout(()=>tone(1568,0.10,'sine',0.03), 180);
      }
    };
    return { play(name){ presets[name]?.(); } };
  })();

  // ---------- Small UI helpers ----------
  function ensureModal(id, titleText) {
    let modal = document.getElementById(id);
    if (!modal) {
      modal = document.createElement('div');
      modal.id = id;
      modal.className = 'modal';
      modal.innerHTML = `
        <h2>${titleText}</h2>
        <div class="modal-body" style="max-height:50vh; overflow:auto;"></div>
        <div style="display:flex; gap:12px; justify-content:center; margin-top:16px;">
          <button class="cyber-btn" data-close>Close</button>
        </div>`;
      document.body.appendChild(modal);
      modal.querySelector('[data-close]').addEventListener('click', ()=> modal.classList.remove('show'));
    }
    return modal;
  }

  // ---------- Hook the game instance ----------
  if (!game._integratedApi) {
    game._integratedApi = true;
    game.moves = [];

    const originalHandleClick = game.handleClick.bind(game);
    const originalHandleRight  = game.handleRightClick.bind(game);
    const originalNewGame      = game.newGame.bind(game);
    const originalShowGameOver = game.showGameOverModal.bind(game);

    // Replace sound system to use WebAudio tones
    const soundMap = { clickSound:'click', flagSound:'flag', explodeSound:'explode', winSound:'win' };
    game.playSound = function(soundId){
      if (!this.soundEnabled) return;
      sfx.play(soundMap[soundId] || 'click');
    };

    game.newGame = function() {
      this.moves = [];
      originalNewGame();
    };
    game.handleClick = function(e) {
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      this.moves.push({t: Date.now(), type:'reveal', row, col});
      return originalHandleClick(e);
    };
    game.handleRightClick = function(e) {
      e.preventDefault(); // ensure no native context menu
      const row = parseInt(e.target.dataset.row);
      const col = parseInt(e.target.dataset.col);
      this.moves.push({t: Date.now(), type:'flag', row, col});
      return originalHandleRight(e);
    };

    function snapshotBoard(ctx) {
      const out = [];
      for (let r=0; r<ctx.size; r++) {
        const row = [];
        for (let c=0; c<ctx.size; c++) {
          row.push({ v: ctx.board[r][c], rev: !!ctx.revealed[r][c], flg: !!ctx.flagged[r][c] });
        }
        out.push(row);
      }
      return out;
    }

    game.showGameOverModal = function(won) {
      originalShowGameOver(won);
      const modal = document.getElementById('gameOverModal');
      const bodyBoxId = 'scoreSubmitBox';
      document.getElementById(bodyBoxId)?.remove();

      if (won) {
        const boxEl = document.createElement('div');
        boxEl.id = bodyBoxId;
        boxEl.style.cssText = 'margin-top:16px; display:flex; gap:10px; justify-content:center; align-items:center; flex-wrap:wrap;';
        boxEl.innerHTML = `
          <div style="color:#0ff; font-size:0.95rem;">Save your score:</div>
          <input id="initialsInput" maxlength="3" placeholder="ABC" 
                 style="text-transform:uppercase; padding:10px; border:2px solid #0ff; border-radius:10px; background:rgba(0,20,40,.7); color:#fff; width:80px; text-align:center; font-family:Orbitron,monospace;">
          <button class="cyber-btn" id="submitScoreBtn">Submit</button>
          <div id="submitScoreMsg" style="width:100%; text-align:center; color:#aaa; font-size:.85rem; margin-top:6px;"></div>
        `;
        // insert after the score area
        modal.querySelector('div').after(boxEl);

        document.getElementById('submitScoreBtn').onclick = async () => {
          const initials = (document.getElementById('initialsInput').value || '').toUpperCase().replace(/[^A-Z]/g,'').slice(0,3);
          const msg = document.getElementById('submitScoreMsg');
          if (initials.length !== 3) { msg.style.color = '#f77'; msg.textContent = 'Please enter exactly 3 letters.'; return; }

          const timeTaken = this.timer|0;
          const finalBoard = snapshotBoard(this);
          const moves = this.moves.slice(0, 1000);

          // Validate first
          msg.style.color = '#0ff'; msg.textContent = 'Validatingâ€¦';
          try {
            const val = await api.validate({ moves, time: timeTaken, board: finalBoard });
            if (!val?.valid) { msg.style.color = '#f77'; msg.textContent = `Validation failed: ${val?.reason || 'unknown'}`; return; }
          } catch (e) { msg.style.color = '#f77'; msg.textContent = `Validation error: ${e.message}`; return; }

          // Save
          msg.textContent = 'Saving scoreâ€¦';
          const savePayload = {
            initials,
            score: parseInt(document.getElementById('finalScore').textContent,10) || this.score,
            time: timeTaken,
            difficulty: this.currentDifficulty,
            grid_size: this.size,
            mines_count: this.mines
          };
          try {
            const saved = await api.saveHighScore(savePayload);
            msg.style.color = '#0f0';
            msg.textContent = `Saved! Rank #${saved?.rank || '?'} â€” showing leaderboardâ€¦`;
            showHighScoresModal(this.currentDifficulty);
          } catch (e) {
            msg.style.color = '#f77';
            msg.textContent = `Save failed: ${e.message}`;
          }
        };
      }
    };
  }

  // ---------- High Scores Modal + Button wiring ----------
  function ensureHighScoresTable(modalBody, items=[]) {
    if (!items.length) {
      modalBody.innerHTML = `<div style="text-align:center; color:#aaa;">No scores yet.</div>`;
      return;
    }
    const table = document.createElement('table');
    table.style.cssText = `width:100%; border-collapse:collapse; font-size:.95rem;`;
    table.innerHTML = `
      <thead>
        <tr>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">#</th>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">Initials</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #0ff;">Score</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #0ff;">Time (s)</th>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">Diff</th>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #0ff;">When</th>
        </tr>
      </thead>
      <tbody></tbody>`;
    const tb = table.querySelector('tbody');
    items.forEach((row, i) => {
      const tr = document.createElement('tr');
      const when = row.created_at ? new Date(row.created_at).toLocaleString() : '';
      tr.innerHTML = `
        <td style="padding:8px;">${i+1}</td>
        <td style="padding:8px;">${row.initials || ''}</td>
        <td style="padding:8px; text-align:right;">${row.score?.toLocaleString?.() ?? row.score}</td>
        <td style="padding:8px; text-align:right;">${row.time}</td>
        <td style="padding:8px;">${row.difficulty}</td>
        <td style="padding:8px;">${when}</td>`;
      tb.appendChild(tr);
    });
    modalBody.innerHTML = '';
    modalBody.appendChild(table);
  }

  async function showHighScoresModal(difficulty='all') {
    const modal = ensureModal('highScoresModal', 'HIGH SCORES');
    const body = modal.querySelector('.modal-body');
    body.innerHTML = `<div style="text-align:center; color:#0ff;">Loadingâ€¦</div>`;
    modal.classList.add('show');
    try {
      const res = await api.highScores(difficulty, 10);
      ensureHighScoresTable(body, res?.high_scores || []);
    } catch (e) {
      body.innerHTML = `<div style="color:#f77;">Failed to load: ${e.message}</div>`;
    }
  }

  document.getElementById('highScoresBtn')?.addEventListener('click', () => {
    const diff = game.currentDifficulty || 'all';
    showHighScoresModal(diff);
  });

  // ---------- Optional background fetches ----------
  (async () => {
    try { await api.stats(); } catch {}
    try { await api.daily(); } catch {}
  })();

  // ---------- Expose for debugging ----------
  window.CyberAPI = { api, showHighScoresModal };
})();

    </script>
  <script>window.API_BASE = 'https://pserver.burtoncummings.io';</script>
  <script src="../analytics.js"></script>
</body>
</html>
